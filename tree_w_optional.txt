package com.byteland

/**
  * Created by aydinf on 14/01/2016.
  */
trait CityTree[+T] {

  import scala.annotation.tailrec

  def getId: Option[T] = this match {
    case n: NodeCity[T] => Some(n.id)
    case l: LeafCity[T] => Some(l.id)
  }

  def getConnected: Option[List[CityTree[T]]] = this match {
    case n: NodeCity[T] => Some(n.connected)
    case l: LeafCity[T] => None
  }
  
  private case class EvalCity[A](id: A) extends CityTree[A]
  
  @tailrec
  private def foldLoop[A, B](a: List[CityTree[A]], z: B)(f: (B, A) => B)(o: (NodeCity[A], List[CityTree[A]]) => List[CityTree[A]]): B = a match {
    case (n: NodeCity[A]) :: tl => foldLoop(o(n, tl), z)(f)(o) // never directly evaluate nodes, function o will create new accumulator
    case (l: LeafCity[A]) :: tl => foldLoop(tl, f(z, l.id))(f)(o) // always evaluate Leaf
    case (e: EvalCity[A]) :: tl => foldLoop(tl, f(z, e.id))(f)(o) // always evaluate Eval
    case _                      => z // will be Nil (empty list)
  }

  def foldPreOrder[B](z: B)(f: (B, T) => B): B = {
    foldLoop(List(this), z)(f) { (n, tl) => EvalCity(n.id) :: n.connected ::: tl }
  }

  def foldPostOrder[B](z: B)(f: (B, T) => B): B = {
    foldLoop(List(this), z)(f) { (n, tl) => n.connected ::: EvalCity(n.id) :: tl }
  }

  def foldLevelOrder[B](z: B)(f: (B, T) => B): B = {
    foldLoop(List(this), z)(f) { (n, tl) => (EvalCity(n.id) :: tl) ::: n.connected }
  }

  def fold[B](z: B)(f: (B, T) => B): B = foldPreOrder(z)(f)

  def size: Int = fold(0) { (sum, v) => sum + 1 }

  def height: Int = {
    def loop[A](t: CityTree[A]): Int = t match {
      case l: LeafCity[A] => 1
      case n: NodeCity[A] => n.getConnected.get.map(loop(_)).max + 1
      case _          => 0
    }
    loop(this) - 1
  }

  def leafCount: Int = {
    @tailrec
    def loop(t: List[CityTree[T]], z: Int): Int = t match {
      case (l: LeafCity[T]) :: tl => loop(tl, z + 1)
      case (n: NodeCity[T]) :: tl => loop(n.getConnected.get ::: tl, z)
      case _ :: tl            => loop(tl, z)
      case _                  => z
    }
    loop(List(this), 0)
  }

  def toSeq: Seq[T] = fold(List[T]()) { (l, v) => v :: l }.reverse

  def toSeqPreOrder: Seq[T] = foldPreOrder(List[T]()) { (l, v) => v :: l }.reverse
  def toSeqPostOrder: Seq[T] = foldPostOrder(List[T]()) { (l, v) => v :: l }.reverse
  def toSeqLevelOrder: Seq[T] = foldLevelOrder(List[T]()) { (l, v) => v :: l }.reverse

  def lastPreOrder: T = toSeqPreOrder.last
  def lastPostOrder: T = toSeqPostOrder.last
  def lastLevelOrder: T = toSeqLevelOrder.last

  def nthPreOrder(n: Int): T = toSeqPreOrder(n)
  def nthPostOrder(n: Int): T = toSeqPostOrder(n)
  def nthLevelOrder(n: Int): T = toSeqLevelOrder(n)
}

case class NodeCity[T](id: T, connected: List[CityTree[T]] = Nil) extends CityTree[T]
case class LeafCity[T](id: T) extends CityTree[T]

//noinspection ScalaStyle
object Run extends App {
  val t: CityTree[Int] = NodeCity(0, List(NodeCity(1, List(NodeCity(2, List(NodeCity(3, List(LeafCity(6), LeafCity(7))))))), LeafCity(4), LeafCity(5)))
  println("tree: " + t)

  //print the value of 1 node navigating from root
  for {
    b <- t.getConnected
    value <- b.head.getId
  } println("1 node: " + value)

  //print the value of 5 node navigating from root
  for {
    b <- t.getConnected
    d <- b.last.getId
  } println("5 node: " + d)

  //no println() is executed for empty node chain
  for {
    b <- t.getConnected
    d <- b.tail.head.getConnected //4
    e <- d.head.getId
  } println("X node SHOUL NOT PRINT!: " + e)

  println("as seq: " + t.toSeq)

  println("count: " + t.size)
  assert(t.size == 8)

  println("height: " + t.height)
  assert(t.height == 4)

  println("leaf count: " + t.leafCount)
  assert(t.leafCount == 4)

  println("as seqPreorder: " + t.toSeqPreOrder)
  println("as seqPostorder: " + t.toSeqPostOrder)
  println("as seqLevelorder: " + t.toSeqLevelOrder)

  println("last preorder :" + t.lastPreOrder)
  println("last postorder :" + t.lastPostOrder)
  println("last levelorder: " + t.lastLevelOrder)

  println("nth preorder 5 : " + t.nthPreOrder(5))
  println("nth postorder 5 : " + t.nthPostOrder(5))
  println("nth levelorder 5 : " + t.nthLevelOrder(5))

}